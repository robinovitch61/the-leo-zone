<!doctype html><html lang=en><head><meta charset=utf-8><title>Leo Robinovitch @ The Leo Zone</title><link rel=icon href=/img/favicon.png type=image/x-icon><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="The personal site of Leo Robinovitch, an American & Canadian Software Engineer in the Bay Area."><link rel=stylesheet href=/sass/main.min.f373b7caf8469f5497cf264480a94adf65adff6d9384dd07f6f7f1ec1024ef2d.css><link rel=stylesheet href=/sass/header.min.3a05763a683cf36d1c69c38bcd70ef997e4139b9f5b7b964ce4ec50f69a2a4e3.css><link rel=stylesheet href=/sass/footer.min.eaac730dad5c96ec74b1b6ad615c2653058b703041364f7f2f29ffe0deb6b650.css><link rel=stylesheet href=/sass/code.min.a20af48ca3a864274a8c935eafe4779c5aec4b9e19e252fb0df3f7147401df13.css><a rel=me href=https://recurse.social/@robinovitch61></a></head><body><header><div class=header-content><a href=/><div class=logo>THE LEO ZONE</div></a><div class=stripes><div class="stripe top"></div><div class="stripe middle"></div><div class="stripe bottom"></div></div><a href=/><div class=sun><div class=stripes></div></div></a><div class=nav><a href=/ target=_self>home</a>
<a href=https://github.com/robinovitch61 target=_blank>github</a>
<a href=/about target=_self>about</a></div></div></header><div class=content><div class=container><h1>react html5 zoom/pan canvas</h1><div class=post-date><p>May 02, 2021</p></div><div class=post><p>A pannable, mouse-centered zoomable, HTML5 canvas template in React + Typescript. You&rsquo;d think this would be a solved problem, but despite the plethora of solutions out there, I couldn&rsquo;t get quite what I wanted for some time. Finally, here it all is in one place for future me and others to use as boilerplate for their embedded interactive canvases in their apps.</p><p>If you see any bugs or possible improvements, please comment on the gist here:</p><p><a href=https://gist.github.com/robinovitch61/483190546bf8f0617d2cd510f3b4b86d>https://gist.github.com/robinovitch61/483190546bf8f0617d2cd510f3b4b86d</a></p><pre tabindex=0><code>import {
  useEffect,
  useCallback,
  useLayoutEffect,
  useRef,
  useState
} from &#34;react&#34;;
import * as React from &#34;react&#34;;

type CanvasProps = {
  canvasWidth: number;
  canvasHeight: number;
};

type Point = {
  x: number;
  y: number;
};

const ORIGIN = Object.freeze({ x: 0, y: 0 });

// adjust to device to avoid blur
const { devicePixelRatio: ratio = 1 } = window;

function diffPoints(p1: Point, p2: Point) {
  return { x: p1.x - p2.x, y: p1.y - p2.y };
}

function addPoints(p1: Point, p2: Point) {
  return { x: p1.x + p2.x, y: p1.y + p2.y };
}

function scalePoint(p1: Point, scale: number) {
  return { x: p1.x / scale, y: p1.y / scale };
}

const ZOOM_SENSITIVITY = 500; // bigger for lower zoom per scroll

export default function Canvas(props: CanvasProps) {
  const canvasRef = useRef&lt;HTMLCanvasElement&gt;(null);
  const [context, setContext] = useState&lt;CanvasRenderingContext2D | null&gt;(null);
  const [scale, setScale] = useState&lt;number&gt;(1);
  const [offset, setOffset] = useState&lt;Point&gt;(ORIGIN);
  const [mousePos, setMousePos] = useState&lt;Point&gt;(ORIGIN);
  const [viewportTopLeft, setViewportTopLeft] = useState&lt;Point&gt;(ORIGIN);
  const isResetRef = useRef&lt;boolean&gt;(false);
  const lastMousePosRef = useRef&lt;Point&gt;(ORIGIN);
  const lastOffsetRef = useRef&lt;Point&gt;(ORIGIN);

  // update last offset
  useEffect(() =&gt; {
    lastOffsetRef.current = offset;
  }, [offset]);

  // reset
  const reset = useCallback(
    (context: CanvasRenderingContext2D) =&gt; {
      if (context &amp;&amp; !isResetRef.current) {
        // adjust for device pixel density
        context.canvas.width = props.canvasWidth * ratio;
        context.canvas.height = props.canvasHeight * ratio;
        context.scale(ratio, ratio);
        setScale(1);

        // reset state and refs
        setContext(context);
        setOffset(ORIGIN);
        setMousePos(ORIGIN);
        setViewportTopLeft(ORIGIN);
        lastOffsetRef.current = ORIGIN;
        lastMousePosRef.current = ORIGIN;

        // this thing is so multiple resets in a row don&#39;t clear canvas
        isResetRef.current = true;
      }
    },
    [props.canvasWidth, props.canvasHeight]
  );

  // functions for panning
  const mouseMove = useCallback(
    (event: MouseEvent) =&gt; {
      if (context) {
        const lastMousePos = lastMousePosRef.current;
        const currentMousePos = { x: event.pageX, y: event.pageY }; // use document so can pan off element
        lastMousePosRef.current = currentMousePos;

        const mouseDiff = diffPoints(currentMousePos, lastMousePos);
        setOffset((prevOffset) =&gt; addPoints(prevOffset, mouseDiff));
      }
    },
    [context]
  );

  const mouseUp = useCallback(() =&gt; {
    document.removeEventListener(&#34;mousemove&#34;, mouseMove);
    document.removeEventListener(&#34;mouseup&#34;, mouseUp);
  }, [mouseMove]);

  const startPan = useCallback(
    (event: React.MouseEvent&lt;HTMLCanvasElement, MouseEvent&gt;) =&gt; {
      document.addEventListener(&#34;mousemove&#34;, mouseMove);
      document.addEventListener(&#34;mouseup&#34;, mouseUp);
      lastMousePosRef.current = { x: event.pageX, y: event.pageY };
    },
    [mouseMove, mouseUp]
  );

  // setup canvas and set context
  useLayoutEffect(() =&gt; {
    if (canvasRef.current) {
      // get new drawing context
      const renderCtx = canvasRef.current.getContext(&#34;2d&#34;);

      if (renderCtx) {
        reset(renderCtx);
      }
    }
  }, [reset, props.canvasHeight, props.canvasWidth]);

  // pan when offset or scale changes
  useLayoutEffect(() =&gt; {
    if (context &amp;&amp; lastOffsetRef.current) {
      const offsetDiff = scalePoint(
        diffPoints(offset, lastOffsetRef.current),
        scale
      );
      context.translate(offsetDiff.x, offsetDiff.y);
      setViewportTopLeft((prevVal) =&gt; diffPoints(prevVal, offsetDiff));
      isResetRef.current = false;
    }
  }, [context, offset, scale]);

  // draw
  useLayoutEffect(() =&gt; {
    if (context) {
      const squareSize = 20;

      // clear canvas but maintain transform
      const storedTransform = context.getTransform();
      context.canvas.width = context.canvas.width;
      context.setTransform(storedTransform);

      context.fillRect(
        props.canvasWidth / 2 - squareSize / 2,
        props.canvasHeight / 2 - squareSize / 2,
        squareSize,
        squareSize
      );
      context.arc(viewportTopLeft.x, viewportTopLeft.y, 5, 0, 2 * Math.PI);
      context.fillStyle = &#34;red&#34;;
      context.fill();
    }
  }, [
    props.canvasWidth,
    props.canvasHeight,
    context,
    scale,
    offset,
    viewportTopLeft
  ]);

  // add event listener on canvas for mouse position
  useEffect(() =&gt; {
    const canvasElem = canvasRef.current;
    if (canvasElem === null) {
      return;
    }

    function handleUpdateMouse(event: MouseEvent) {
      event.preventDefault();
      if (canvasRef.current) {
        const viewportMousePos = { x: event.clientX, y: event.clientY };
        const topLeftCanvasPos = {
          x: canvasRef.current.offsetLeft,
          y: canvasRef.current.offsetTop
        };
        setMousePos(diffPoints(viewportMousePos, topLeftCanvasPos));
      }
    }

    canvasElem.addEventListener(&#34;mousemove&#34;, handleUpdateMouse);
    canvasElem.addEventListener(&#34;wheel&#34;, handleUpdateMouse);
    return () =&gt; {
      canvasElem.removeEventListener(&#34;mousemove&#34;, handleUpdateMouse);
      canvasElem.removeEventListener(&#34;wheel&#34;, handleUpdateMouse);
    };
  }, []);

  // add event listener on canvas for zoom
  useEffect(() =&gt; {
    const canvasElem = canvasRef.current;
    if (canvasElem === null) {
      return;
    }

    // this is tricky. Update the viewport&#39;s &#34;origin&#34; such that
    // the mouse doesn&#39;t move during scale - the &#39;zoom point&#39; of the mouse
    // before and after zoom is relatively the same position on the viewport
    function handleWheel(event: WheelEvent) {
      event.preventDefault();
      if (context) {
        const zoom = 1 - event.deltaY / ZOOM_SENSITIVITY;
        const viewportTopLeftDelta = {
          x: (mousePos.x / scale) * (1 - 1 / zoom),
          y: (mousePos.y / scale) * (1 - 1 / zoom)
        };
        const newViewportTopLeft = addPoints(
          viewportTopLeft,
          viewportTopLeftDelta
        );

        context.translate(viewportTopLeft.x, viewportTopLeft.y);
        context.scale(zoom, zoom);
        context.translate(-newViewportTopLeft.x, -newViewportTopLeft.y);

        setViewportTopLeft(newViewportTopLeft);
        setScale(scale * zoom);
        isResetRef.current = false;
      }
    }

    canvasElem.addEventListener(&#34;wheel&#34;, handleWheel);
    return () =&gt; canvasElem.removeEventListener(&#34;wheel&#34;, handleWheel);
  }, [context, mousePos.x, mousePos.y, viewportTopLeft, scale]);

  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; context &amp;&amp; reset(context)}&gt;Reset&lt;/button&gt;
      &lt;pre&gt;scale: {scale}&lt;/pre&gt;
      &lt;pre&gt;offset: {JSON.stringify(offset)}&lt;/pre&gt;
      &lt;pre&gt;viewportTopLeft: {JSON.stringify(viewportTopLeft)}&lt;/pre&gt;
      &lt;canvas
        onMouseDown={startPan}
        ref={canvasRef}
        width={props.canvasWidth * ratio}
        height={props.canvasHeight * ratio}
        style={{
          border: &#34;2px solid #000&#34;,
          width: `${props.canvasWidth}px`,
          height: `${props.canvasHeight}px`
        }}
      &gt;&lt;/canvas&gt;
    &lt;/div&gt;
  );
}
</code></pre></div></div></div><footer><div class=nav><a href=/ target=_self>home</a></div><div class=woopsy>measure twice, cut once</div></footer></body></html>