<!doctype html><html lang=en><head><meta charset=utf-8><title>Leo Robinovitch @ The Leo Zone</title>
<link rel=icon href=/img/favicon.png type=image/x-icon><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A simple hash table implementation in C, by Leo Robinovitch."><link rel=stylesheet href=/sass/main.min.f556718ec0bb9b6dcdda59801767eccb02391d0c5fc0b6cc682396d541edd0fa.css><link rel=stylesheet href=/sass/header.min.3a05763a683cf36d1c69c38bcd70ef997e4139b9f5b7b964ce4ec50f69a2a4e3.css><link rel=stylesheet href=/sass/footer.min.eaac730dad5c96ec74b1b6ad615c2653058b703041364f7f2f29ffe0deb6b650.css><link rel=stylesheet href=/sass/code.min.a20af48ca3a864274a8c935eafe4779c5aec4b9e19e252fb0df3f7147401df13.css><a rel=me href=https://recurse.social/@robinovitch61></a></head><body><header><div class=header-content><a href=/><div class=logo>THE LEO ZONE</div></a><div class=stripes><div class="stripe top"></div><div class="stripe middle"></div><div class="stripe bottom"></div></div><a href=/><div class=sun><div class=stripes></div></div></a><div class=nav><a href=/ target=_self>home</a>
<a href=https://github.com/robinovitch61 target=_blank>github</a>
<a href=/about target=_self>about</a></div></div></header><div class=content><div class=container><h1>a simple hash table in C</h1><div class=post-date><p>Jun 06, 2023</p></div><div class=post><p>I implemented a simple <a href=https://en.wikipedia.org/wiki/Hash_table>hash table</a> in C when solving a problem in <a href=https://csprimer.com/courses/>CS Primer</a>. Solving it
helped me gain better intuition around hash functions, pointers, and memory segments like the stack and the heap.</p><h2 id=basics>Basics</h2><p>You have probably encountered a hash table in the wild, like
a <a href=https://github.com/python/cpython/blob/main/Objects/dictobject.c><code>dict</code> in Python</a>, <a href=https://github.com/golang/go/blob/master/src/runtime/map.go><code>map</code> in Go</a>, or <a href=https://github.com/v8/v8/blob/main/src/objects/ordered-hash-table.cc><code>Map</code> in JavaScript</a>. Hash tables
associate a key with a value. Setting, looking up, and deleting values is average O(1) time complexity &ndash; fast.</p><p>Under the hood of a hash table, there is an array of &ldquo;buckets&rdquo; or &ldquo;slots&rdquo;. I&rsquo;ll use the term buckets going forward. The
buckets array holds the values stored in the hash table. When you associate a key with a value, the key&rsquo;s hash is used
to obtain the index of its value in the buckets array. Since the index is quick and easy to derive from the key, setting
and looking up by key (usually) takes little work.</p><p>There are a number of design decisions when implementing a hash table:</p><ul><li>hash function selection</li><li>initial size of the buckets array</li><li>collision resolution (when many keys hash to the same index)</li><li>when to resize or compact the buckets array</li></ul><p>The C hash table implementation I walk through below starts with a buckets array of size 4, has no resizing or
compaction, accepts only strings as keys, and uses separate chaining (linked list) hash collision resolution.</p><h3 id=hash-functions>Hash functions</h3><p>A hash function takes an argument (in this case, a key) and deterministically returns a number. As a contrived example,
<code>my_hash_func(key="hello")</code> returns 123 for the lifetime of the program<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. A different key,
say <code>my_hash_func(key="world")</code> might return a different number, say 127. There are a number of desirable
characteristics for a good hash function<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>.</p><h3 id=the-buckets-array>The buckets array</h3><p>When setting a value, the hash table internally runs the key through its hash function, takes the output modulo the
length of its buckets array, and puts the value at that index of the buckets array. For example, say &ldquo;hello&rdquo; hashed to
123 as above, and our buckets array is of length 4. <code>123 % 4</code> is 3. If I wanted to associate the key &ldquo;hello&rdquo; with the
number 72 in my hash table, the buckets array would look like this in pseudo-code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=o>&gt;</span> <span class=n>h</span><span class=p>[</span><span class=s2>&#34;hello&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=mi>72</span>
</span></span><span class=line><span class=cl><span class=o>&gt;</span> <span class=n>h</span><span class=o>.</span><span class=n>show_buckets</span><span class=p>()</span> <span class=c1># &#34;hello&#34; hashes to 123, and 123 % 4 = 3</span>
</span></span><span class=line><span class=cl><span class=n>bucket</span> <span class=mi>0</span><span class=p>:</span> <span class=n>NULL</span>
</span></span><span class=line><span class=cl><span class=n>bucket</span> <span class=mi>1</span><span class=p>:</span> <span class=n>NULL</span>
</span></span><span class=line><span class=cl><span class=n>bucket</span> <span class=mi>2</span><span class=p>:</span> <span class=n>NULL</span>
</span></span><span class=line><span class=cl><span class=n>bucket</span> <span class=mi>3</span><span class=p>:</span> <span class=p>(</span><span class=s2>&#34;hello&#34;</span><span class=p>,</span> <span class=mi>72</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>NULL</span>
</span></span></code></pre></div><p>Each bucket optionally contains the head of a linked list. Here, buckets 0 through 2 are empty and bucket 3 contains a
linked list with a single value (72) associated with the key &ldquo;hello&rdquo;.</p><p>When looking up the value of key &ldquo;hello&rdquo;, the hash map will once again infer that the key &ldquo;hello&rdquo; lives in bucket 3,
then traverse the linked list in bucket 3. Once it finds the matching key &ldquo;hello&rdquo; in the linked list, it returns the
associated value of 72. If no matching key is found in the linked list, the hash table may throw an error (e.g.
<code>KeyError</code> in Python) or return a null pointer like my implementation below.</p><p>You can imagine that if a lot of keys hash-and-mod to bucket 3, the linked list there will be very long, and
setting/getting values from the hash table will no longer be performant. This is why most implementations resize the
number of buckets when the buckets array gets too full<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>.</p><h3 id=the-heap>The heap</h3><p>I&rsquo;ll be mentioning the heap frequently. You can think of the stack and heap as different memory spaces (or segments, Ã 
la <a href=https://en.wikipedia.org/wiki/Segmentation_fault>segfault</a>) in RAM during program runtime. Variables on the stack are scoped to a function &ndash; they are all
deallocated and are no longer referencable when the function returns. The heap is used to store variables that need to
be referenced outside the scope of the function that defines them. A common way variables are stored on the heap is with
the function <code>malloc</code>. They are then referencable until the program calls the function <code>free</code> on them. Failure to <code>free</code>
unused variables on the heap as the program continues to run is what is referred to as a memory leak, as the heap memory
may repeatedly fill up, causing the process to request more heap memory.</p><h2 id=hash-table-c-implementation>Hash table C implementation</h2><p>In C, a <code>struct</code> is a collection of named and typed fields. I define two <code>struct</code>s. One is called <code>Entry</code> and represents
an item in the hash table.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>Entry</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=o>*</span><span class=n>key</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=o>*</span><span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>Entry</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>Entry</span><span class=p>;</span>
</span></span></code></pre></div><p><code>Entry</code> contains three fields:</p><ul><li><code>key</code>, the key associated with the value</li><li><code>val</code>, a void (&ldquo;any type&rdquo;) pointer to the value itself</li><li><code>next</code>, a pointer to the next <code>Entry</code> for collision resolution</li></ul><p>All fields are pointers in order to ensure each <code>Entry</code> is a static size in memory &ndash; the output of the <code>sizeof</code>
function for each field is fixed, therefore the output of <code>sizeof(Entry)</code> is constant.</p><p>The other <code>struct</code> represents the hash table itself:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>HashTable</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Entry</span> <span class=o>**</span><span class=n>buckets</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>nBuckets</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>HashTable</span><span class=p>;</span>
</span></span></code></pre></div><p><code>HashTable</code> contains 2 fields:</p><ul><li><code>buckets</code>, a pointer to an array of pointers to <code>Entry</code>s (the memory tables below may help if this is initially
confusing)</li><li><code>nBuckets</code>, the number of buckets in the Hashmap</li></ul><p>Similar to <code>Entry</code>, since both fields are a static size, a <code>HashTable</code> instance is also a static size.</p><h3 id=the-djb2-hash-function>The djb2 hash function</h3><p>The hash function used operates only on strings, and is called <a href=http://www.cse.yorku.ca/~oz/hash.html>djb2</a> written by <a href=https://en.wikipedia.org/wiki/Daniel_J._Bernstein>Daniel Bernstein</a><sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>uint32_t</span> <span class=nf>hash</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>h</span> <span class=o>=</span> <span class=mi>5381</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>((</span><span class=n>c</span> <span class=o>=</span> <span class=o>*</span><span class=n>s</span><span class=o>++</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>h</span> <span class=o>=</span> <span class=mi>33</span> <span class=o>*</span> <span class=n>h</span> <span class=o>+</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>h</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The <code>get_bucket</code> function returns the bucket index for a given key:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>uint32_t</span> <span class=nf>get_bucket</span><span class=p>(</span><span class=n>HashTable</span> <span class=o>*</span><span class=n>h</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>key</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>hash</span><span class=p>(</span><span class=n>key</span><span class=p>)</span> <span class=o>%</span> <span class=n>h</span><span class=o>-&gt;</span><span class=n>nBuckets</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=creating-an-empty-hash-table>Creating an empty hash table</h3><p>When creating a new <code>HashTable</code>, memory is allocated on the heap for the <code>HashTable</code> and its buckets array. Each entry
in the buckets array, i.e. each bucket, is a pointer to an <code>Entry</code>. A pointer to the <code>HashTable</code> is returned.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>HashTable</span> <span class=o>*</span><span class=nf>HashTable_new</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>nBuckets</span> <span class=o>=</span> <span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>HashTable</span> <span class=o>*</span><span class=n>h</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=n>HashTable</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>h</span><span class=o>-&gt;</span><span class=n>nBuckets</span> <span class=o>=</span> <span class=n>nBuckets</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>h</span><span class=o>-&gt;</span><span class=n>buckets</span> <span class=o>=</span> <span class=nf>calloc</span><span class=p>(</span><span class=n>nBuckets</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>Entry</span> <span class=o>*</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>h</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Note that <a href=https://man7.org/linux/man-pages/man3/calloc.3p.html><code>calloc</code></a> is called instead of <a href=https://man7.org/linux/man-pages/man3/malloc.3p.html><code>malloc</code></a> when initializing the buckets array to ensure that all items are
initially zero&rsquo;d out (NULL).</p><p>After calling <code>HashTable_new</code>, <code>malloc</code>/<code>calloc</code> has been called twice, so the heap looks something like this:</p><table><thead><tr><th>Address</th><th>Pseudo-value</th><th>Description</th></tr></thead><tbody><tr><td>0xFF00</td><td><code>HashTable(4, <span style=color:red>0xFF40</span>)</code></td><td>HashTable itself</td></tr><tr><td><span style=color:red>0xFF40</span></td><td><code>[NULL, NULL, NULL, NULL]</code></td><td>Initial buckets</td></tr></tbody></table><h3 id=associating-a-key-and-value>Associating a key and value</h3><p>Let&rsquo;s define a <code>HashTable_set</code> function to associate keys and values:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>HashTable_set</span><span class=p>(</span><span class=n>HashTable</span> <span class=o>*</span><span class=n>h</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>key</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>val</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>bucket</span> <span class=o>=</span> <span class=nf>get_bucket</span><span class=p>(</span><span class=n>h</span><span class=p>,</span> <span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Entry</span> <span class=o>*</span><span class=n>v</span> <span class=o>=</span> <span class=n>h</span><span class=o>-&gt;</span><span class=n>buckets</span><span class=p>[</span><span class=n>bucket</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// traverse the linked list at the key&#39;s bucket index
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=p>(</span><span class=n>v</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>strcmp</span><span class=p>(</span><span class=n>v</span><span class=o>-&gt;</span><span class=n>key</span><span class=p>,</span> <span class=n>key</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// if Entry is found, overwrite its value
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>v</span><span class=o>-&gt;</span><span class=n>val</span> <span class=o>=</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>v</span> <span class=o>=</span> <span class=n>v</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// found no existing entry - create one
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// and make it the head of the linked list
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Entry</span> <span class=o>*</span><span class=n>newVal</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=n>Entry</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>newVal</span><span class=o>-&gt;</span><span class=n>key</span> <span class=o>=</span> <span class=nf>strdup</span><span class=p>(</span><span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>newVal</span><span class=o>-&gt;</span><span class=n>val</span> <span class=o>=</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>newVal</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>h</span><span class=o>-&gt;</span><span class=n>buckets</span><span class=p>[</span><span class=n>bucket</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>h</span><span class=o>-&gt;</span><span class=n>buckets</span><span class=p>[</span><span class=n>bucket</span><span class=p>]</span> <span class=o>=</span> <span class=n>newVal</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>We get the key&rsquo;s bucket index from its hash, then traverse the optional linked list of <code>Entry</code>s at that index in the
buckets array. If we find an existing key, we overwrite its value with the new value and return. If no existing <code>Entry</code>
for the key is found, allocate memory for a new <code>Entry</code>, create and store a copy of the key using <a href=https://man7.org/linux/man-pages/man3/strdup.3.html>strdup</a> (which uses
<code>malloc</code> under the hood), set its value, and insert it as the head<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup> of the linked list at the appropriate bucket
index.</p><p>Now we can run the following code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>HashTable</span> <span class=o>*</span><span class=n>h</span> <span class=o>=</span> <span class=nf>HashTable_new</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// hash(&#34;item a&#34;) % 4 = 1 for this example
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>HashTable_set</span><span class=p>(</span><span class=n>h</span><span class=p>,</span> <span class=s>&#34;item a&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// &gt;breakpoint&lt;
</span></span></span></code></pre></div><p>At the breakpoint, the stack looks something like this:</p><table><thead><tr><th>Address</th><th>Pseudo-value</th><th>Description</th></tr></thead><tbody><tr><td><span style=color:green>0x0000</span></td><td><code>5</code></td><td>Integer a</td></tr></tbody></table><p>The heap looks something like this:</p><table><thead><tr><th>Address</th><th>Pseudo-value</th><th>Description</th></tr></thead><tbody><tr><td>0xFF00</td><td><code>HashTable(4, <span style=color:red>0xFF40</span>)</code></td><td>HashTable itself</td></tr><tr><td><span style=color:red>0xFF40</span></td><td><code>[NULL, <span style=color:blue>0xFF80</span>, NULL, NULL]</code></td><td>Buckets array</td></tr><tr><td><span style=color:blue>0xFF80</span></td><td><code>Entry(<span style=color:indigo>0xFFB0</span>, <span style=color:green>0x0000</span>, NULL)</code></td><td>Inserted entry</td></tr><tr><td><span style=color:indigo>0xFFB0</span></td><td><code>"item a"</code></td><td>Key for entry</td></tr></tbody></table><p>And the buckets of <code>h</code> looks like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>bucket</span> <span class=mi>0</span><span class=o>:</span> <span class=nb>NULL</span>
</span></span><span class=line><span class=cl><span class=n>bucket</span> <span class=mi>1</span><span class=o>:</span> <span class=p>(</span><span class=s>&#34;item a&#34;</span><span class=p>,</span> <span class=mi>5</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>NULL</span>
</span></span><span class=line><span class=cl><span class=n>bucket</span> <span class=mi>2</span><span class=o>:</span> <span class=nb>NULL</span>
</span></span><span class=line><span class=cl><span class=n>bucket</span> <span class=mi>3</span><span class=o>:</span> <span class=nb>NULL</span>
</span></span></code></pre></div><h3 id=looking-up-values-by-key>Looking up values by key</h3><p>For looking up values by key, <code>HashTable_get</code> is similar but simpler than <code>HashTable_set</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>HashTable_get</span><span class=p>(</span><span class=n>HashTable</span> <span class=o>*</span><span class=n>h</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>key</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>bucket</span> <span class=o>=</span> <span class=nf>get_bucket</span><span class=p>(</span><span class=n>h</span><span class=p>,</span> <span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Entry</span> <span class=o>*</span><span class=n>v</span> <span class=o>=</span> <span class=n>h</span><span class=o>-&gt;</span><span class=n>buckets</span><span class=p>[</span><span class=n>bucket</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// traverse the linked list at the key&#39;s bucket index
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=p>(</span><span class=n>v</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// if Entry is found, return the value
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=nf>strcmp</span><span class=p>(</span><span class=n>v</span><span class=o>-&gt;</span><span class=n>key</span><span class=p>,</span> <span class=n>key</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=k>return</span> <span class=n>v</span><span class=o>-&gt;</span><span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>v</span> <span class=o>=</span> <span class=n>v</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// no key found, return NULL
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>A void pointer to the value rather than the value itself is returned.</p><h3 id=deleting-entries>Deleting entries</h3><p>Hash tables often also include functionality to delete an entry, like Python&rsquo;s <a href=https://docs.python.org/3/reference/simple_stmts.html#the-del-statement><code>del</code> keyword</a>. The
<code>HashTable_delete</code> function allows the user or program to mark entries as removed:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>HashTable_delete</span><span class=p>(</span><span class=n>HashTable</span> <span class=o>*</span><span class=n>h</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>key</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>bucket</span> <span class=o>=</span> <span class=nf>get_bucket</span><span class=p>(</span><span class=n>h</span><span class=p>,</span> <span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Entry</span> <span class=o>*</span><span class=n>prev</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Entry</span> <span class=o>*</span><span class=n>v</span> <span class=o>=</span> <span class=n>h</span><span class=o>-&gt;</span><span class=n>buckets</span><span class=p>[</span><span class=n>bucket</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// traverse the linked list at the key&#39;s bucket index
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=p>(</span><span class=n>v</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>strcmp</span><span class=p>(</span><span class=n>v</span><span class=o>-&gt;</span><span class=n>key</span><span class=p>,</span> <span class=n>key</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// found Entry to delete
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=p>(</span><span class=n>prev</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// if head of linked list,
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>// set head to next value
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>h</span><span class=o>-&gt;</span><span class=n>buckets</span><span class=p>[</span><span class=n>bucket</span><span class=p>]</span> <span class=o>=</span> <span class=n>v</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// if middle or end of linked list,
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>// remove without disrupting pointers
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>prev</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>v</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=c1>// free allocated heap memory for the Entry&#39;s
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// key and the Entry itself
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nf>free</span><span class=p>(</span><span class=n>v</span><span class=o>-&gt;</span><span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=nf>free</span><span class=p>(</span><span class=n>v</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>prev</span> <span class=o>=</span> <span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>v</span> <span class=o>=</span> <span class=n>v</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// if no Entry found, do nothing
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>So after running the following:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>HashTable</span> <span class=o>*</span><span class=n>h</span> <span class=o>=</span> <span class=nf>HashTable_new</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nf>HashTable_set</span><span class=p>(</span><span class=n>h</span><span class=p>,</span> <span class=s>&#34;item a&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>HashTable_delete</span><span class=p>(</span><span class=n>h</span><span class=p>,</span> <span class=s>&#34;item a&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// &gt;breakpoint&lt;
</span></span></span></code></pre></div><p>At the breakpoint, the stack looks something like this:</p><table><thead><tr><th>Address</th><th>Pseudo-value</th><th>Description</th></tr></thead><tbody><tr><td>0x0000</td><td><code>5</code></td><td>Integer a</td></tr></tbody></table><p>And the heap looks the same as when the hash table was originally initialized:</p><table><thead><tr><th>Address</th><th>Pseudo-value</th><th>Description</th></tr></thead><tbody><tr><td>0xFF00</td><td><code>HashTable(4, <span style=color:red>0xFF40</span>)</code></td><td>HashTable itself</td></tr><tr><td><span style=color:red>0xFF40</span></td><td><code>[NULL, NULL, NULL, NULL]</code></td><td>Buckets array</td></tr></tbody></table><h3 id=discarding-the-hash-table>Discarding the hash table</h3><p>Finally, the user may want to free the entire hash table, so let&rsquo;s provide them with a <code>HashTable_free</code> function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>HashTable_free</span><span class=p>(</span><span class=n>HashTable</span> <span class=o>*</span><span class=n>h</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// traverse every linked list and free
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// each Entry and its key
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>b</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>b</span> <span class=o>&lt;</span> <span class=n>h</span><span class=o>-&gt;</span><span class=n>nBuckets</span><span class=p>;</span> <span class=n>b</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Entry</span> <span class=o>*</span><span class=n>v</span> <span class=o>=</span> <span class=n>h</span><span class=o>-&gt;</span><span class=n>buckets</span><span class=p>[</span><span class=n>b</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>v</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>Entry</span> <span class=o>*</span><span class=n>next</span> <span class=o>=</span> <span class=n>v</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=nf>free</span><span class=p>(</span><span class=n>v</span><span class=o>-&gt;</span><span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=nf>free</span><span class=p>(</span><span class=n>v</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>v</span> <span class=o>=</span> <span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// free the buckets array and the HashTable itself
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>free</span><span class=p>(</span><span class=n>h</span><span class=o>-&gt;</span><span class=n>buckets</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>h</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This completes the implementation of a simple hash table in C.</p><h2 id=alternatives-and-discussion>Alternatives and discussion</h2><p>There are a couple things I know I&rsquo;m doing imperfectly above, and probably more that I don&rsquo;t know about:</p><ul><li><a href=https://linux.die.net/man/3/strncmp><code>strncmp</code></a> should be used instead of <code>strcmp</code> in order to avoid unexpected behavior if non-null-terminated strings
are passed to it</li><li>the code should check if <code>malloc</code>, <code>strcmp</code>, and their analogues fail. In particular, this is important in embedded or
older environments where the OS may not kill processes before address space is exhausted</li></ul><p>Some easy optimizations:</p><ul><li>use <code>(h &lt;&lt; 5) + h</code> instead of <code>33 * h</code> in <code>djb2</code> as they are equivalent, but bit shifting & addition may produce
faster machine code than multiplication depending on the compiler</li><li>store the hash of the key in each <code>Entry</code> and only compare the keys if the hash values match</li></ul><p>More involved improvements:</p><ul><li>support non-string keys</li><li>use a balanced binary tree at each bucket rather than a linked list</li><li>resize the buckets array once it gets too full</li><li>switch from chained resolution with linked lists to a different technique like open addressing<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup></li><li>maintain insertion order</li><li>add a random seed to each process that uses the hash table in order to prevent <a href=./dos_via_algo_complexity_attack.pdf>DoS attacks</a></li></ul><p>Thanks to Oz and <a href=https://csprimer.com/courses/>CS Primer</a> for this problem. I found it a great exercise to learn more about hash tables and
the design decisions behind them, hash functions, the C programming language, and memory management.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><strong>a hash function returns the same number for the same input for the <em>life of the program</em></strong>: I say for the life
of the program and not &ldquo;always&rdquo; because most programming languages <a href=https://en.wikipedia.org/wiki/Hash_function#Deterministic>add an unpredictable random value</a> (a
seed) to the hash function input. This value is the same for the lifetime of the process, but different across
processes. The reason for this is interesting &ndash; if attackers know or can infer the hash function output by providing
application input, they
can <a href=./dos_via_algo_complexity_attack.pdf>purposefully increase the number of hash table collisions in order to DoS attack the server</a>. Because
of this random seed, <a href=https://docs.python.org/3/reference/datamodel.html#object.__hash__>Python <code>sets</code> are not ordered</a>.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><strong>desirable characteristics of a hash function</strong>: read <a href=./choosing_hash_function.pdf>this discussion</a>
from <a href=https://sites.cs.queensu.ca/courses/cisc235/>Queens&rsquo; CISC-235</a>, but Tl;DR a good hash function does the following:</p><ul><li>gives equal weight to all elements (digits, chars) in the key</li><li>uniformly distributes keys throughout the output space</li><li>is fast to compute</li><li>is discontinuous (keys that are close in value don&rsquo;t necessarily map to outputs that are close in value)</li></ul><p>The <a href=http://www.cse.yorku.ca/~oz/hash.html>djb2</a> hash function used here is pretty good on these criteria.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p><strong>when is the bucket array too full?</strong>: the load factor is the proportion of buckets with at least one value. When
the load factor reaches some high enough value, it may be a good idea to resize the hash table by creating a larger
buckets array, reinserting all values into it, and replacing the old bucket array with the new one.</p><p>As long as the hash function evenly distributes keys to output values, you
can expect about equal distribution of values throughout the buckets array, i.e. equally long linked lists when using
separate chaining collision resolution.</p><p>Hash tables using separate chaining hash collisions may tolerate higher load factors than those using open addressing,
as the extra operations required to seek an item is bound by the max length of the linked lists. Open addressing
collisions may cause up to the number of buckets extra operations as an empty bucket is sought, so the max load factor
is usually lower when this is used. Python, which uses open addressing, <a href=https://github.com/python/cpython/blob/2587b9f64eefde803a5e0b050171ad5f6654f31b/Objects/dictobject.c#L399-L409>uses a max load factor of 1/2 to
1/3</a>.</p><p>It&rsquo;s also possible to implement a hash table that resizes based on frequency of access or overall process load, maybe
resizing only during periods of lower load.</p><p>The load factor can also be too low, which indicates an overuse of memory. In that case, your hash table may compact in
order to require less buckets and free up memory.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p><strong>the djb2 hash function</strong>: this is a pretty strange looking function at first. What are these magic numbers 33
and 5381? There is some explanation for them <a href=https://stackoverflow.com/a/13809282>here on stackoverflow</a>, but long
story short, they seem to provide a hash function with all the desirable properties discussed in a footnote.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p><strong>why insert values at the head of the linked list?</strong>: we could have also appended them to the end of the linked
list, but it would involve keeping a reference to the previous <code>Entry</code> around or doing a look-ahead to find the linked
list&rsquo;s termination point. If the aim is to create a generally performant data structure, there&rsquo;s no way to know whether
users will be referencing recently inserted values more often than previously inserted values, so it&rsquo;s not such an
important decision whether to put the new entry on the head or tail. In a more complete implementation, resizing the
buckets array to reduce the length of the linked lists makes this decision even more arbitrary.&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p><strong>what is open addressing?</strong>: <a href=https://en.wikipedia.org/wiki/Open_addressing>open addressing</a> is a technique to efficiently locate empty buckets in
which to place values during hash collisions. The best resource I&rsquo;ve found to deeply understand open addressing is <a href=https://just-taking-a-ride.com/inside_python_dict/chapter1.html>this
explorable explanation of Python dicts</a>, which is absolutely worth your time if you enjoyed this post.&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div></div></div><footer><div class=nav><a href=/ target=_self>home</a></div><div class=woopsy>measure twice, cut once</div></footer></body></html>